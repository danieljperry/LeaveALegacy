(mod (
    OWNER_PUBKEY       ; (curryed) The public key of the address that is allowed to spend the coin before time timelock expires
    COIN_VALUE         ; (curryed) The value of this coin, in mojos
    WAIT_TIME          ; (curryed) The amout of time before the timelock expires, in seconds
    INNER_PUZZLE_HASH  ; (curryed) The hash of another puzzle, with curryed arguments. Can be any puzzle, including another Legacy Coin. Can be '()' for an empty puzzle.
    inner_puzzle       ; The inner puzzle with curryed arguments, only to be revealed when attempting to spend the coin. Can be '()' for an empty puzzle.
    inner_solution     ; The solution to the inner puzzle. Can be '()' for an empty solution
    msg                ; A message to be included when spending the coin, can be anything
    spend_pubkey       ; The public key of the address that is attempting to spend the coin; can be same as OWNER_PUBKEY, or different
    receive_puzzlehash ; The puzzlehash of the wallet to receive the coin when it's spent
    )

    (include condition_codes.clib)
    (include sha256tree1.clvm)

    ; Make sure the inner puzzle's treehash matches the hash that was curryed in.
    ; If they match, then execute the inner puzzle.
    ; If they don't match, raise an error and exit.
    (defun-inline verify_and_run_inner (inner_puzzle inner_solution)
        (if (= INNER_PUZZLE_HASH (sha256tree1 inner_puzzle))
            (a inner_puzzle inner_solution)
            (x "Inner puzzle does not match inner puzzle hash.")
        )
    )
    
    ; check_for_inner_puzzle will first assert the timelock associated with the current puzzle.
    ; This is done in lieu of having an oracle that can verify the death of the coin's owner.
    ; If there is an inner puzzle, then execute it.
    ; If not, then proceed to spend the coin.

    (defun-inline check_for_inner_puzzle (COIN_VALUE WAIT_TIME INNER_PUZZLE_HASH inner_puzzle inner_solution msg spend_pubkey receive_puzzlehash)
        (c
            (list ASSERT_SECONDS_RELATIVE WAIT_TIME)
        
            (if (= INNER_PUZZLE_HASH ())
                (spend_coin COIN_VALUE spend_pubkey msg receive_puzzlehash)
                (verify_and_run_inner inner_puzzle inner_solution)
            )
        )
    )

    ; spend_coin will check the aggregated signature. If valid, then the spend can go through.
    ; There is no timelock associated with this method, but one may have been asserted previously.
    ; Note that ASSERT_MY_AMOUNT is not needed because COIN_VALUE is curried in.
    (defun-inline spend_coin (COIN_VALUE spend_pubkey msg receive_puzzlehash)
        (list
            (list AGG_SIG_ME spend_pubkey (sha256 msg))
            (list CREATE_COIN receive_puzzlehash COIN_VALUE)
            (list CREATE_COIN_ANNOUNCEMENT COIN_VALUE)
        )
    )

    ; Main method
    ;
    ; Check if the spend_pubkey matches the OWNER_PUBKEY.
    ;
    ; If yes, then the owner may spend the coin immediately,
    ; pending any outer puzzle timelocks that have previously been asserted.
    ;
    ; If no, then see if there is an inner puzzle.

    (if (= OWNER_PUBKEY spend_pubkey)
        (spend_coin COIN_VALUE spend_pubkey msg receive_puzzlehash)
        (check_for_inner_puzzle COIN_VALUE WAIT_TIME INNER_PUZZLE_HASH inner_puzzle inner_solution msg spend_pubkey receive_puzzlehash)
    )
)